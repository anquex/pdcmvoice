\documentclass[a4paper,14pt,openright]{report}

\usepackage[latin1]{inputenc}
\usepackage[italian]{babel}
\usepackage[T1]{fontenc}
\usepackage{latexsym}
\usepackage{graphicx}
\usepackage{epsfig}
\usepackage{amsmath,amssymb,amsthm}
\usepackage[none]{hyphenat} 

\usepackage{fancyhdr}
\setcounter{tocdepth}{3}

\include{miei_comandi}
\frenchspacing
%\pagestyle{headings} % {headings,plain ,empty}
\linespread{1.3}
\DeclareGraphicsRule{.eps,.ps,.png}{bmp}{.bb}{} % formati utilizzabili con ordine di preferenza 
                                                % cosi non devo indicare le estensioni
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}


%\author{\emph{Marco Bettiol}\quad{} 586580\\\emph{Antonio Quercia}\quad{}  588537}

\title{}
\begin{document}

\include{mytitle}

\tableofcontents


\chapter{DFT}
\section{Definizione}


Un vettore $x$ di lunghezza N può essere visto come una sequenza $x_0,...,x_{N-1}$ di N numeri complessi. Si definisce $X$ \emph{trasformata discreta di Fourier (DFT, discrete Fourier transform)}  di $x$ la sequenza $X_0,...,X_{N-1}$ espressa dalla seguente relazione:
\begin{equation}
\label{eq:def-dft}
X_k=\sum_{n=0}^{N-1}x_ne^{-\jmath\frac{2\pi}{N}kn} \quad k=0,...,N-1
\end{equation}
Ricordando la \emph{Formula di Eulero}

\begin{equation*} 
e^{\pm i 2\pi\omega x} = \cos( 2\pi \omega x) \pm i \sin(2\pi \omega x)
\end{equation*}
è evidente come, in generale, $X$ possa risultare in una sequenza complessa sebbene $x$ fosse reale.\\
La relazione inversa della \eqref{eq:def-dft}, chiamata \emph{trasformata discreta inversa di Fourier (IDFT, inverse discrete Fourier transform)} è data da:
\begin{equation}
x_n=\frac{1}{N}\sum_{k=0}^{N-1}X_ke^{\jmath\frac{2\pi}{N}kn} \quad k=0,...,N-1
\label{def_idft}
\end{equation}
Da \ref{def_idft} si può notare che i numeri complessi $X_k$ rappresentano l'ampiezza e la fase delle diverse componenti sinusoidali del "`segnale"' d'ingresso $x_n$.
\\Introduciamo quindi la seguente notazione per indicare DFT e IDFT
\begin{align*}
X &= \mathcal{F}x\\
x &= \mathcal{F}^{-1}X
\label{def_idft}
\end{align*}
e inoltre indichiamo esplicitamente con $x_N$ (pedice maiuscolo) un vettore $x$ $N$-dimensionale e con $X_N$ la sua trasformata.


%A normalization of 1/\sqrt{N} for both the DFT and IDFT makes the transforms unitary, which has some theoretical advantages, but it is often more practical in numerical computation to perform the scaling all at once as above (and a unit scaling can be convenient in other ways).

\section{Proprietà}

Descriviamo alcune delle proprietà più significative della DFT, ovvero consideriamo quelle proprietà che sono alla base delle applicazioni della DFT. Le prime proprietà discendono direttamente dalla definizione dell'operatore DFT e riguardano la linearità,la periodicità e la simmetria. La linearità viene utilizzata specialmente nelle applicazioni
in cui il vettore di cui bisogna calcolare la DFT si può decomporre nelle sue componenti armoniche e attraverso l'analisi della DFT di tali componenti si possono trarre informazioni significative sul vettore iniziale (questo è ad esempio il principio alla base dell'analisi armonica di funzioni periodiche). La proprietà di periodicità consente
di prolungare periodicamente il vettore di cui calcolare la DFT senza alterarne il risultato numerico. Infine la simmetria trova applicazione negli schemi di memorizzazione alla base degli algoritmi numerici per il calcolo di una DFT.\\
La maggior parte delle proprietà valide per la trasformata di Fourier a tempo continuo hanno un analogo equivalente anche per la DFT.\\ Il cambiamento più significativo da apportare ai teoremi per adattarli al caso finito-discreto è quello di modificare gli indici per tenere conto della periodicità della DFT, ovvero prendere gli indici modulo $\mathbf{N}$.

\noindent Date $X$ e $Y$ le DFT di $x$ e $y$ rispettivamente, valgono:
\begin{itemize}


\item Completezza:\\
La DFT è una trasformazione \emph{lineare e invertibile}:
\begin{equation}
\mathcal{F} : \mathbb{C}^N\longrightarrow\mathbb{C}^N
\end{equation}
dove $\mathbb{C}$ è l'insieme complesso.
\[x\xrightleftharpoons[\mathcal{F}^{-1}]{\mathcal{F}} X \]
DFT e IDFT mappano vettori complessi $N$-dimensionali in vettori complessi $N$-dimensionali attraverso una corrispondenza biunivoca.

\item Ortogonalità:\\
I vettori $e^{\jmath \frac{2\pi}{N}kn}$ formano una \emph{base ortogonale} per l'insieme dei vettori complessi $N$-dimensionali:
\begin{equation}
\sum_{n=0}^{N-1}(e^{\jmath\frac{2\pi}{N} kn})(e^{-\jmath\frac{2\pi}{N}k'n})=N\delta_{kk'}
\end{equation}
dove $\delta_{kk'}$ \`e il delta di Kronecker. 
\[\delta_{kk'} = 
\begin{cases} 
1 & \text{if } k = k' \\
0 & \text{if } k \neq k'
\end{cases}\]
Questa condizione pu\`o essere sfruttata per ricavare la formula della IDFT dalla definizione di DFT.

\item Il teorema di Plancherel e il teorema di Parseval:\\
Il \emph{teorema di Plancherel} dice che:
\begin{equation}
\sum_{n=0}^{N-1}x_ny_n^*=\frac{1}{N}\sum_{k=0}^{N-1}X_kY_k^*
\end{equation}
Il \emph{teorema di Parseval} \`e un caso particolare del teorema di Plancherel e afferma che:
\begin{equation}
\sum_{n=0}^{N-1}|x_n|^2=\frac{1}{N}\sum_{k=0}^{N-1}|X_k|^2
\end{equation}

\item Periodicità:\\
Se la relazione \ref{eq:def-dft} che definisce la DFT è valutata per tutti i $k$ interi anzichè soltanto $k=0,...,N-1$, allora la sequenza infinita risultante \`e un'\emph{estensione periodica} di periodo $N$ della DFT. Tale periodicità può essere mostrata direttamente dalla definizione:
\begin{eqnarray}
X_{k+N}&=&\sum_{n=0}^{N-1}x_ne^{-\jmath\frac{2\pi}{N}(k+N)n}\\
&=&\sum_{n=0}^{N-1}x_ne^{-\jmath\frac{2\pi}{N}kn}e^{-\jmath 2\pi n}\\
&=&\sum_{n=0}^{N-1}x_ne^{-\jmath\frac{2\pi}{N}kn}\\
&=&X_k
\end{eqnarray}
dove si è utilizzato il fatto che $e^{-2\pi \jmath}=1$. Allo stesso modo pu\`o essere mostrato che la \ref{def_idft} porta a un'estensione periodica della IDFT.

\item Il \emph{Circular shift theorem}:\\
Moltiplicare $x_N$ per una fase lineare $e^{-\jmath\frac{2\pi}{N}nm}$, per un qualche $m$ intero, è equivalente ad uno shift circolare di $X_N$ di $m$ posizioni: $X_k$ diventa $X_{k-m}$, il cui pedice si deve intendere come \emph{modulo N}. Analogamente, uno shift circolare di $x_N$ corrisponde alla moltiplicazione di $X_N$ per una fase lineare.
\begin{equation}
se\;\mathcal{F}((x_n))_k=X_k
\end{equation}
\begin{equation}
allora\;\mathcal{F}((x_ne^{\jmath\frac{2\pi}{N}nm}))_k=X_{k-m}
\end{equation}
\begin{equation}
e\;\mathcal{F}((x_{n-m}))_k=X_ke^{-\jmath\frac{2\pi}{N}km}
\end{equation}

\item \emph{Linear Convolution Theorem}\\
Siano $x=x_N$ e $y=y_N$ due vettori arbitrari $N$-dimensionali e sia $z=x \ast y$, un vettore di $2N-1$ componenti ottenuto dalla convoluzione lineare $\ast$.\\ Allora,\\
\begin{equation}
	z_i=\sum_{j=\max\{0,i-N+1\}}^{\min\{i,N-1\}}{x_i y_{i-j}} \qquad 0\leq i \leq 2N-1
\end{equation}
\\
dove i limiti superiore e inferiore della sommatoria sono scelti in modo tale che $i$ e $i-j$ siano sempre nell'intervalllo $[0$ $N-1]$.
Possiamo calcolare la convoluzione lineare utilizzando la DFT nel seguente modo:\\
\begin{equation}	
	(z|0_1)= \mathcal{F}_{2N}^{-1}(\mathcal{F}_{2N} (x|0_{N}) \odot \mathcal{F}_{2N} (y|0_{N})
\end{equation}\\
dove $\odot$ indica il prodotto componente per componente e $(x|0_k)$ indica il vettore ottenuto estendendo il vettore $x_{N}$ con padding di $k$ zero in coda.

\item \emph{Cyclic Convolution Theorem}\\
Siano $x=x_N$ e $y=y_N$ due vettori arbitrari $N$-dimensionali, definiamo \emph{convoluzione ciclica} di $x$ e $y$, indicata con $x \circledast y$, il vettore w di $N$ componenti dato da:
\\
\begin{equation}
	w_i=\sum_{j=0}^{N-1}{x_i y_{(i-j) \mod N }} \qquad 0\leq i \leq N-1
\end{equation}
\\
Possiamo calcolare la convoluzione ciclica utilizzando la DFT nel seguente modo:\\
\begin{equation}	
	w= \mathcal{F}_{N}^{-1}(\mathcal{F}_{N} x \odot \mathcal{F}_{N} y)
\end{equation}\\
dove $\odot$ indica il prodotto componente per componente.

%
% Corollari convoluzione ciclica <--> lineare (pucci)
%
\end{itemize}

\section{Defizione Matriciale}
Dalla defizione \eqref{eq:def-dft} di DFT emerge immadiatamente una interpretazione matriciale della \emph{trasformata discreta di Fourier} \\
\begin{equation}
X=\mathcal{F}(x) = F_N x
\end{equation}\\
con 
\begin{equation}
x=
\left(
\begin{array}{c}
x_0\\
x_1\\
...\\
x_{N-1}	
\end{array}\right)
\end{equation}
\vskip 5pt e\vskip 5pt
\begin{equation}
F_N=
\left(
\begin{array}{clrr}
\omega_N^{0\cdot0} & \omega_N^{0\cdot1} & ... & \omega_N^{0\cdot(N-1)}\\
\omega_N^{1\cdot0} & \omega_N^{1\cdot1} & ... & \omega_N^{1\cdot(N-1)}\\
      ...     &     ...       & ... &         ...\\
\omega_N^{(N-1)\cdot0} & \omega_N^{(N-1)\cdot1} & ... & \omega_N^{(N-1)\cdot(N-1)}	
\end{array}\right)
\end{equation}
Il termine 
\begin{equation}
\omega_N=e^{-\jmath \frac{2\pi}{N}}
\end{equation}
\`e una \emph{radice complessa N-esima dell'unita}.\\
L'elemento in posizione $(i,j)$ della matrice \`e $\omega_N^{ij}$, con $i,j=0,1,...,N-1$.\\
Analogamente è possibile esprimere la IDFT come:
\begin{equation}
x=\mathcal{F}^{-1}(X)=F_N^{-1}X
\end{equation}
Dove $F_N^{-1}$ \`e la \emph{matrice inversa} di $F_N$ e può essere facilmente ottenuta da $F$ attraverso
\begin{equation}
	F_N^{-1} =\frac{1}{N} F_N^{*}
\end{equation}
dove pertanto in posizione $(i,j)$ di $F_N^{-1}$ è presente il valore
 $\frac{1}{N}\omega_N^{-ij}$
\subsection{Analogie tra DFT e IDFT}
Questa affinità tra $F_N$ e $F_N^{-1}$ mette in risalto come in realtà la procedura per il calcolo di DFT e IDFT sia esattamente la stessa a meno di minimi adattamenti.\\
In altre parole è possibile calcolare la IDFT attraverso lo stesso algoritmo di \emph{forward computation} della DFT attraverso un semplice preprocessing dell'input e moltiplicazione per un fattore di scala:
\begin{equation}
	\mathcal{F}^{-1}(\{x_n\})= \frac {1}{N}\mathcal{F}(\{x_{N-n}\})
\end{equation}
dove l'operazione effettuata sull'input risulta essere un \emph{inversione dell'input modulo $N$}:\vskip 5pt
\begin{equation}
\left(
\begin{array}{c}
x_0\\x_1\\x_2\\...\\x_{N-2}\\x_{N-1}\\
\end{array}\right)\longrightarrow
\left(
\begin{array}{c}
x_0\\x_{N-1}\\x_{N-2}\\...\\x_{2}\\x_{1}\\
\end{array}\right)
\end{equation}\vskip 5pt
Analogamente è possibile sfruttare la seguente proprietà per il calcolo della IDFT
\vskip 5pt
\begin{equation}	
	\mathcal{F}^{-1}\left( x \right) = \frac{1}{N}{(\mathcal{F} (x^*))}^*
	\label{eq:inverse_computing_rule}
\end{equation}
\vskip 5pt
coniugando l'input, applicando la DFT, coniugando l'output e quindi scalando.

\section{Segnali di durata finita: relazione tra trasformata di Fourier e DFT}
\chapter{Calcolo della DFT}

La diffusione nell'utilizzo della DFT è principalmente dovuta all'introduzione, avvenuta negli anni '60, di una classe di algoritmi computazionale efficienti per la sua valutazione: la \emph{(Fast Fourier Transform, i.e. trasformata veloce di Fourier)}.\\ Essa rende possibile in taluni casi l'elaborazione in tempo reale (sistemi di navigazione, trasmissione e processo di segnali vocali o televisivi) e consente di risolvere alcuni problemi di grandi dimensioni che risulterebbero altrimenti intrattabili.\\
L'FFT viene normalmente attribuita a Cooley e Tukey. Di fatto questo particolare algoritmo venne scoperto (ed usato) da Gauss nel XIX secolo. Pare che in realtà l'algoritmo sia stato riscoperto ed utilizzato varie volte (anche prima del lavoro di Cooley e Tuckey menzionato sopra).
Grazie alla FFT, infatti, è possibile implementare al calcolatore operazioni nel dominio della frequenza, cioè utilizzando le trasformate di Fourier, con complessità di calcolo inferiore a quella ottenibile implementando lo stesso calcolo nel dominio del tempo.\\
\newpage
\section{Attraverso la definizione}
La tecnica di calcolo banale passa per la definizione stessa di DFT
\begin{equation*}
X_k=\sum_{n=0}^{N-1}x_ne^{-\jmath\frac{2\pi}{N}kn} \quad k=0,...,N-1
\end{equation*}
ed essendo 
\begin{equation*}
\mathcal{F} : \mathbb{C}^N\longrightarrow\mathbb{C}^N
\end{equation*}
ci sono $N$ termini da calcolare, ognuno dei quali richiede $N$ moltiplicazioni e $N-1$ addizzioni complesse. Anche evidando di calcolare le moltiplicazioni per $\omega_{N}^{0}=1$ si devono comunque effettuare in totale $2(N-1)^2$ operazioni complesse. Il costo è pertanto $O(N^2)$

Nel dettaglio ogni moltiplicazione complessa $\lambda = z_1 \cdot z_2 = (a + jb) \cdot (c + jd)$ si sviluppa in 
\begin{align*}
m1 &= (a + b) \cdot c\\
m2 &= (d + c) \cdot b\\
m3 &= (d - c) \cdot a\\
\rm{Re}(\lambda) &= m1 - m2\\
\rm{Im}(\lambda) &= m1 + m3\\
\end{align*}
richiedendo 4 moltiplicazioni reali e 2 addizioni e pertanto il numero di operazioni macchina totali risultante è $4(N-1)^2$ moltiplicazioni e $2N(N-1)+2(N-1)^2= 2(N-1)(2N-1)$ addizioni.

Nel modello di calcolo da noi considerato assumeremo, come effettivamente si verifica per i moderni apparecchi di calcolo, che il tempo impiegato per effetuare una addizione o moltiplicazione sia lo stesso.

Inoltre, poichè nel caso della FFT, tutte le moltiplicazioni complesse coinvolgono un "`twiddle factor"' $\omega_N^l = c + jd$, e un ulteriore termine è possibile precalcolare, oltre che precalcolarli è possibile salvarsi anche i risultati intermedi $c+d$ e $c-d$ in modo che una moltiplicazione complessa richeda solo $5$ operazioni totali. 

%Un'altra scomposizione che può risultare vantaggiosa è $(a+jb)(c+jd)=a(c+d)-d(a+b)+j[a(c+d)+c(b-a)]$
%3 moltiplicazioni e 5 addizioni reali.
%As noted earlier, most high-performance workstations can perform multiplications as additions
%fast as additions

\section{Algoritmi per il calcolo di FFT}
Sia $T(N)$ il tempo di calcolo associato ad un problema di cardinalità $N$ e supponiamo per semplicità $N=2^\nu$.\\
Se partizioniamo gli $N$ dati in due sottoinsiemi di $N/2$ dati:
\begin{equation}
	N \longrightarrow \frac{N}{2} + \frac{N}{2},
\end{equation}
risolviamo i due sottoproblemi e ricombiniamo le due soluzioni, il tempo di calcolo diviene:
\begin{equation}	
	T(N) = 2 \cdot T\left(\frac{N}{2}\right)+ R(N)
\end{equation}
con $R(N)$ pari al costo di combinazione. Allo stesso risultato si arriva se $R(N)$ rappresenta il costo di costruzione e/o ricombinazione dei due sottoproblemi.

Non è difficile verificare che se $R(N)= O(N)$, cioè il costo di ricombinazione è lineare nei dati e si itera il procedimento fino ad $N$ sottoinsiemi di un solo dato, il tempo di calcolo relativo alla procedura diventa:
\begin{equation}
	T(N) = O(N \cdot \log_2(N))
\end{equation}
qualsiasi sia la complessita di calcolo originale $T(N)$, purchè di tipo polinomiale, cioè del tipo
\begin{equation}
T(N) = O(N^\alpha), \quad \alpha \in \mathbb{R}
\end{equation}
Ovviamente, minore è la complessità originaria (quindi l'esponente $\alpha$) e più piccolo sarà il tempo di calcolo al quare si arriva applicando il principio \emph{"`divide et impera"'}; in ogni caso, comunque, esso sarà dell'ordine di $N \cdot \log_2 N$

Osserviamo inoltre che il principio \emph{"`divide et impera"'} conduce spontaneamente a strutture di calcolo parallele. Con $N=2_\nu$, le partizioni dei dati più efficienti sono le più "`spontanee"', e sono "`schematizzate"' nella figura seguente per $N=8$
\vskip 30pt
\begin{figure}[h!]
  \centering
      \includegraphics[width=\textwidth]{immagini/tipi_algoritmi}
  \caption{Tipologie di FFT}
\end{figure}
%\includegraphics[scale=0.35]{tipi_algoritmi}
\vskip 10pt

\subsection{Cooley-Tukey Algorithm - DIT}
Gli algoritmi di decimazione radix-2 nel tempo si costituiscono a partire dalla seguente scomposizione ricorsiva.\\
Consideriamo un vettore $x$ di lunghezza $N=2^\nu$. Dividiamo i valori in ingresso in elementi di posizione pari e dispari\\
\[n = 
\begin{cases} 
2 \cdot r \\
2 \cdot r +1
\end{cases}\]

\subsubsection{Schema di scomposizione}

Sapendo che $\omega_N^2= \omega_{\frac{N}{2}}$, la componente $X_k$ della DFT può essere espressa come
\setlength{\jot}{17pt}{{\begin{align} 
X_k &=\sum_{n=0}^{N-1}x_n \omega_N^{nk} \qquad \text{con}\quad \omega_N=e^{-\jmath\frac{2\pi}{N}} \\
\label{eq:cooley-tukey-sommatorie-1}
&=\sum_{r=0}^{N/2-1}x_{2r} \omega_N^{2rk} + \sum_{r=0}^{N/2-1}x_{2r+1} \omega_N^{(2r+1)k}\\
\label{eq:cooley-tukey-sommatorie-2}
&=\underbrace{\sum_{r=0}^{N/2-1}x_{2r} \omega_{\frac{N}{2}}^{rk}}_{X_{even}} + \omega_N^{k} \underbrace{\sum_{r=0}^{N/2-1}x_{2r+1} \omega_{\frac{N}{2}}^{rk}}_{X_{odd}}\\
&=X_{even} \quad +\quad \omega_N^{k} \cdot X_{odd} \qquad k=0,1, ..., N-1
\end{align}}

Entrambe le sommatorie in \eqref{eq:cooley-tukey-sommatorie-2} possono quindi essere interpretate come DFT di taglia $N/2$: la prima coinvolge gli elementi in posizione pari $\{x_{2k}|k=0,1,...,N/2-1\}$ mentre la seconda gli elementi in posizione dispari $\{x_{2k+1}|k=0,1,...,N/2-1\}$. Ci siamo quindi ricondotti a due sottoproblemi analoghi a quello di partenza ma di daglia dimezzata.\\
Definiendo $y_r=x_{2r}$ e $z_r=x_{2r+1}$ e quindi le rispettive DFT
\begin{equation}
	Y_{k}=\sum_{r=0}^{\frac{N}{2}-1} y_r \omega_{\frac{N}{2}}^{rk}, \qquad k=0,1,...,N/2-1
\end{equation}
e
\begin{equation}
	Z_{k}=\sum_{r=0}^{\frac{N}{2}-1} z_r \omega_{\frac{N}{2}}^{rk}, \qquad k=0,1,...,N/2-1
\end{equation}
dopo che la soluzione di questi due problemi è stata ricorsivamente calcolata è possibile calcolare i primi $N/2$ termini di $X$ attraverso
\begin{equation}
\label{eq:CT-X_even}
	X_k= Y_k+\omega_N^k Z_k, \qquad k=0,1,...,N/2-1 
\end{equation}
e utilizzando il fatto che $\omega_N^{\frac{N}{2}+k}=-\omega_N^{k}$ e $\omega_{\frac{N}{2}}^{\frac{N}{2}}=1$, i rimanenti termini sono dati da:
\begin{align}
X_{k+\frac{N}{2}} &= \sum_{r=0}^{\frac{N}{2}-1} y_r \omega_{\frac{N}{2}}^{(r+\frac{N}{2})k}+\omega_{N}^{(k+\frac{N}{2})} \sum_{r=0}^{\frac{N}{2}-1} z_r \omega_{\frac{N}{2}}^{(r+\frac{N}{2})k}\\
&= \sum_{r=0}^{\frac{N}{2}-1} y_r \omega_{\frac{N}{2}}^{rk}+\omega_{N}^{k} \sum_{r=0}^{\frac{N}{2}-1} z_r \omega_{\frac{N}{2}}^{rk}\\
\label{eq:CT-X_odd}
&= Y_k-\omega_N^k Z_k, \qquad k=0,1,...,N/2-1
\end{align}
Solitamente le relazioni di calcolo espresse in \eqref{eq:CT-X_even} e \eqref{eq:CT-X_odd} sono graficamente rappresentate in un grafo computazione come \emph{"`Cooley-Tukey butterly"'}

\begin{figure}[h!]
  \centering
      \includegraphics[width=0.5\textwidth]{immagini/cooley-tukey-butterfly}
  \caption{Cooley-Tukey butterfly}
\end{figure}

\subsubsection{Complessità}
Il costo di ricombinazione è dato da $3N$ dovuto alla moltiplicazione per il "`twiddle factor"' e $2N$ dovuto alle somme. Pertanto risulta
\[T(N) =
\begin{cases} 
2T(\frac{N}{2}) + 5N & \text{se } N\geq 2 \\
0 & \text{se } N=1 
\end{cases}\]
e quindi
\begin{equation}
	T(N)= 5N\log(N)
\end{equation}

%!COMPLETARE!
%
% vedere se completare qui o dedicargli più spazio
% cooley-tukey N=pq paragrafo a parte?
%
%
 
\subsection{Gentleman-Sande Algorithm - DIF}
Una strategia leggermente diversa da quella dello schema di Cooley e Tukey sta alla base la versione dell'algoritmo FFT radix-2 introdotta da Gentleman e Sande. Tale variante si basa sul decomporre ripetutamente il vettore DFT da calcolare. Si osserva che le componoenti con indice pari della DFT si possono esprimere come una DFT di lunghezza $N/2$ costruita a partire da un vettore ottenuto combinando le componenti del vettore di input che distano di $N/2$. Analogo ragionamento si fa per le componenti con indice dispari della DFT da calcolare.

\subsubsection{Schema di scomposizione}
Se dividiamo gli $N=2^\nu$ elementi di $x_N$ nelle due sotto sequenze $x_{head}=(x_0,x_1,...,x_{\frac{N}{2}-1})$ e $x_{tail}=(x_{\frac{N}{2}},x_{\frac{N}{2}+1},...,x_{N-1})$, la DFT di $x_N$ si può scrivere nella forma

\setlength{\jot}{17pt}{\begin{align} 
X_k &=\sum_{n=0}^{N-1}x_n \omega_N^{nk} \qquad \text{con}\quad \omega_N=e^{-\jmath\frac{2\pi}{N}} \\
&=\sum_{n=0}^{N/2-1}x_n \omega_N^{nk} + \sum_{n=N/2-1}^{N-1}x_{n} \omega_N^{nk} \qquad \text{per} \quad n'=n-\frac{N}{2}\\
\label{eq:dft-dif-div}
&=\sum_{n=0}^{N/2-1}x_n \omega_N^{nk} + \sum_{n'=0}^{N/2-1}x_{\frac{N}{2}+n'} \omega_N^{(\frac{N}{2}+n')k} \qquad  \quad \omega_N^{N\frac{k}{2}}= (-1)^k\\
&=\sum_{n=0}^{N/2-1}\left[x_n  + (-1)^k x_{\frac{N}{2}+n}\right]
\end{align}}

Notiamo che la \eqref{eq:dft-dif-div} non è una DFT su $N/2$ punti in quanto è presente il termine $\omega_N^{nk}$ invece di $\omega_{\frac{N}{2}}^{nk}$

Procedendo separatamente con il calcolo dei valori di $X_k$ di posto pari $\left((-1)^K=1\right)$ e dispari $\left((-1)^K=-1\right)$ si ottiene


\setlength{\jot}{17pt}{\begin{align} 
X_{2r} &=\sum_{n=0}^{N/2-1}\left[\underbrace{x_n  + x_{\frac{N}{2}+n}}_{y_{n}}\right] \omega_{N/2}^{rn} \qquad r=0,1,...,N/2-1\\
X_{2r+1} &=\sum_{n=0}^{N/2-1}\left[(\underbrace{x_n  - x_{\frac{N}{2}+n}}_{z_{n}}) \omega_{N}^{n} \right] \omega_{N/2}^{rn}
\end{align}}

Il calcolo della DFT su $N=2^\nu$ punti viene quindi ricondotto a

\begin{enumerate}
	\item il calcolo di due segnali di lunghezza $N/2$ corrispondenti rispettivamente alla somma di $x_{head} +x_{tail}$ e alla differenza $x_{head}-x_{tail}$
	\setlength{\jot}{17pt}{\begin{align} 
	y_{n}&=x_{n}+x_{\frac{N}{2}+n} \qquad n=0,1,...,N/2-1\\
	z_{n}&=x_{n}-x_{\frac{N}{2}+n}
	\end{align}}
	che corrisponde a $N/2$ DFT su coppie punti, [$x_{n}$ $x_{\frac{N}{2}+n}$]. Infatti
	
			\begin{equation}
		F_2=
		\left(
		\begin{array}{cr}
		1 & 1\\1 & -1	
		\end{array}\right)
		\end{equation}
	\item alla moltiplicazione di $z_{n}$ per $\omega_{N}^{n}$
	\item al calcolo di due DFT su $N/2$ punti, una su $y_{n}$ e l'altra su $z_{n}\omega_{N}^{n}$
\end{enumerate}

Con l'algoritmo DIF quindi si precondizionano i dati dei due blocchi di lunghezza $N/2$ in modo che una trasformata su $N/2$ dati dia i valodi di $X_k$ per $k$ pari e l'altra sempre su $N/2$ dati dia i valori di $X_k$ per $k$ dispari.
Tutto il lavoro è quindi effettuato nel passo \emph{"`divide"'} che richiede di effettuare somma e sottrazione di coppie e moltiplicazione per il \emph{"`twiddle factor"'} mentre il passo \emph{"`conquer"'} è banale poichè l'output delle due trasformate, prese "`alternativamente"',fornisce immediatamente la trasformata dell'ingresso originale.

Solitamente il passo di suddivisione è graficamente rappresentato in un grafo computazione come \emph{"`Gentleman-Sande butterly"'}

\begin{figure}[h!]
  \centering
      \includegraphics[width=0.5\textwidth]{immagini/gentleman-sande-butterfly}
  \caption{Gentleman-Sande butterfly}
\end{figure}

\subsubsection{Complessità}

Il passo di suddivisione richiede $N$ addizioni complesse e $N/2$ moltiplicazioni complesse e pertanto anche in questo caso la complessità risulta $T(N)= 5N\log(N)$.
%!COMPLETARE!
%
% Manca analisi della complessità, dire che si usa sempre la radice N-esima dell'unità e che l'output è non ordinato (vedi slide), vedi mian pg 173
%
%
%
\subsection{Split-radix Algorithm}
L'idea che sta alla base dell'algoritmo Split-radix è quella di usare la decomposizione radix-2 e radix-4 contemporaneamente, ovvero il problema iniziale di taglia $N$ viene scomposto in un problema di taglia $N/2$ e 2 problemi di taglia $N/4$. La scomposizione di seguito è della tipologia DIT.

\subsubsection{Schema di scomposizione}
\begin{align}
X_r &= \sum_{l=0}^{N-1}{x_l\omega_N^{rl}}, \qquad r=0,1,...,N-1\\
&=\sum_{k=0}^{\frac{N}{2}-1}{x_{2k}\omega_N^{r(2k)}}+\sum_{k=0}^{\frac{N}{4}-1}{x_{4k+1}\omega_N^{r(4k+1)}}+\sum_{k=0}^{\frac{N}{4}-1}{x_{4k+3}\omega_N^{r(4k+3)}}\\
&=\sum_{k=0}^{\frac{N}{2}-1}{x_{2k}\omega_N^{r(2k)}}+\omega_N^{r}\sum_{k=0}^{\frac{N}{4}-1}{x_{4k+1}\omega_N^{r(4k)}}+\omega_N^{3r}\sum_{k=0}^{\frac{N}{4}-1}{x_{4k+3}\omega_N^{r(4k)}}
\end{align}
$x_N$ è quindi scomposto in 3 sottosequenze: $\{y_k|y_k= x_{2k}, 0\leq k \leq N/2-1\}$ , 
$\{z_k|z_k= x_{4k+1}, 0\leq k \leq N/4-1\}$ , $\{h_k|h_k= x_{4k+3}, 0\leq k \leq N/4-1\}$ e sono deviniti 3 sotto problemi sfruttando il fatto che $\omega_{\frac{N}{2}} = \omega_{N}^2$ e
$\omega_{\frac{N}{4}}= \omega_{N}^4$

\begin{equation}
Y_r=\sum_{k=0}^{\frac{N}{2}-1}{x_{2k}\omega_{N}^{r(2k)}} =\sum_{k=0}^{\frac{N}{2}-1}{x_{2k}{(\omega_{N}^{2})}^{rk}} =\sum_{k=0}^{\frac{N}{2}-1}{y_{k}\omega_{\frac{N}{2}}^{rk}}, \qquad r=0,1,... ,N/2-1
\end{equation}

\begin{equation}
Z_r=\sum_{k=0}^{\frac{N}{2}-1}{x_{4k+1}\omega_{N}^{r(4k)}} =\sum_{k=0}^{\frac{N}{4}-1}{x_{4k+1}{(\omega_{N}^{4})}^{rk}} =\sum_{k=0}^{\frac{N}{4}-1}{z_{k}\omega_{\frac{N}{4}}^{rk}}, \qquad r=0,1,... ,N/4-1
\end{equation}

\begin{equation}
H_r=\sum_{k=0}^{\frac{N}{2}-1}{x_{4k+3}\omega_{N}^{r(4k)}} =\sum_{k=0}^{\frac{N}{4}-1}{x_{4k+3}{(\omega_{N}^{4})}^{rk}} =\sum_{k=0}^{\frac{N}{4}-1}{h_{k}\omega_{\frac{N}{4}}^{rk}}, \qquad r=0,1,... ,N/4-1
\end{equation}

dopo che ognuno dei tre sottoproblemi è stato risolto, ricordando che $Y_r$ è periodico di periodo $N/2$ e $Z_r$ e $H_R$ sono periodici di  $N/4$, la soluzione al problema originale di taglia N può essere ottenuta come:

\begin{align}
\label{eq:split-radix-conquer-1}
X_r &= Y_r+\omega_N^rZ_r+\omega_N^{3r}H_r \nonumber \\ 
&= Y_r+\left(\omega_N^rZ_r+\omega_N^{3r}H_r\right), \qquad 0\leq r\leq\frac{N}{4}-1,\\
\label{eq:split-radix-conquer-2}
X_{r+\frac{N}{4}} &= Y_{r+\frac{N}{4}}+\omega_N^{r+\frac{N}{4}}Z_r+\omega_N^{3({r+\frac{N}{4}})}H_r \nonumber\\
&= Y_{r+\frac{N}{4}}- j\left(\omega_N^{r}Z_r-\omega_N^{3r}H_r\right), \qquad 0\leq r\leq\frac{N}{4}-1,\\
\label{eq:split-radix-conquer-3}
X_{r+\frac{N}{2}} &= Y_{r}+\omega_N^{r+\frac{N}{2}}Z_r+\omega_N^{3({r+\frac{N}{2}})}H_r \nonumber\\
&= Y_{r}-\left(\omega_N^{r}Z_r+\omega_N^{3r}H_r\right), \qquad 0\leq r\leq\frac{N}{4}-1,\\
\label{eq:split-radix-conquer-4}
X_{r+\frac{3N}{4}} &= Y_{r+\frac{N}{4}}+\omega_N^{r+\frac{3N}{4}}Z_r+\omega_N^{3({r+\frac{3N}{4}})}H_r \nonumber\\
&= Y_{r+\frac{N}{4}}+ j\left(\omega_N^{r}Z_r-\omega_N^{3r}H_r\right), \qquad 0\leq r\leq\frac{N}{4}-1,
\end{align}

Le relazioni espresse in \eqref{eq:split-radix-conquer-1} \eqref{eq:split-radix-conquer-2} \eqref{eq:split-radix-conquer-3} \eqref{eq:split-radix-conquer-4} sono solitamente rappresentate in un grafo computazione come \emph{"`unsymmetric DIT split-radix butterly"'}
\vskip 10pt
\begin{figure}[h!]
  \centering
      \includegraphics[width=\textwidth]{immagini/split-radix-dit-butterfly}
  \caption{split-radix butterfly}
\end{figure}
Proprio questa struttura irregolare dello split-radix, sebbene non comporti problemi per le implementazioni sequenziali, rende molto difficile l'organizzazione del calcolo su sistemi paralleli.
%http://cnx.org/content/m12031/latest/#Bruun
       

\subsubsection{Complessità}
Essendo $Z_r$ e $H_r$ di taglia $N/4$ il calcolo dei prodotti $\omega_N^rZ_r$ e $\omega_N^{3r}H_r$ richiede in totale $N/2$ moltiplicazioni complesse e le somme parziali in \eqref{eq:split-radix-conquer-1} \eqref{eq:split-radix-conquer-2} \eqref{eq:split-radix-conquer-3} \eqref{eq:split-radix-conquer-4} richiedono in totale altre $N/2$ addizioni complesse.\\
Sfruttando le proprietà delle radici $\omega_N^{0}$, $\omega_N^{\pm\frac{N}{2}}$,$\omega_N^{\pm\frac{N}{4}}$, $\omega_N^{\pm\frac{N}{8}}$ $\omega_N^{\pm\frac{3N}{8}}$ è possibile ridurre ulteriormente il numero di moltiplicazioni complesse.\\
Riassumendo, il costo computazionale complessivo di una chiamata risorsiva è di $6N-16$ operazioni
Otteniamo quindi la relazione
\[T(N) =
\begin{cases} 
T(\frac{N}{2}) + 2T(\frac{N}{4})+6N-16 & \text{se } N=4^\nu > 4 \\
16 & \text{se } N=4\\
4 & \text{se } N=2\\ 
\end{cases}\]

\noindent e che, risolvendo, fornisce
\begin{equation}
	T(N)= 4N\log(N) -6N +8
\end{equation}
Il guadagno asintotico rispetto alle implementazioni radix-2 è quindi circa del 25\%.
\subsection{Altri Algoritmi}

\subsubsection*{Goertzel's Algorithm} %fft-lecture.pdf
Questo algoritmo, implementato come filtro IIR, è utilizzato in DSP quando si è interessati a conoscere solo alcune delle componenti in frequenza $X_k$ di una sequenza $x_N$

\begin{align*}
	X_{k} &\stackrel{\text{\emph{def}}}{=} \sum_{n=0}^{N-1} x[n] \omega_N^{nk} = 1 \cdot \sum_{n=0}^{N-1} x[n] \omega_N^{nk}, \quad \text{con}\quad \omega_N^{-kN}=1\\
	&= \omega_N^{-kN} \sum_{n=0}^{N-1} x[n] \omega_N^{nk} = \sum_{n=0}^{N-1} x[n] \omega_N^{-k(N-n)}\\
	\left.y_k[n]\right|_{n=N}&= \left.\left[x[n]\ast \left( \omega_N^{-nk} u[n]\right)\right]\right|_{n=N}
\end{align*}
che è una convoluzione discreta.
\begin{equation*}
	x[n] \longrightarrow \fbox{$h[n]=\omega_N^{-nk} u[n]$} \longrightarrow y_k[n]
\end{equation*}
L'algoritmo, espresso come equazione alle differenze del primo ordine, fornisce
\begin{equation*}
	y_k[n] = x [n] +  \omega_N^{-k} y_k[n-1]  \quad \text{con} \quad y_k[-1]=0
\end{equation*}
Notiamo che $x[n]$ è definito solo per $0\leq n \leq N-1$ e perciò $x[N]=0$ e che per calcolare la $k$-esima componente $X_k$  si utilizza solo la radice $\omega_N^{-k}$.
Il calcolo di $X_k$ richiede tempo $O(N)$. Quindi per calcolare tutta la DFT si ha complessità $O(N^2)$. Tuttavia se si è interessati solo a $M$ frequenze risulta vantaggiosa rispetto agli algoritmi FFT $O(N \log2(N))$ fin tanto che $ M\leq\log2(N)$
%
% propagazione errore veloce....
%
%

\subsubsection*{Good-Thomas - Prime Factor Algorithm} %fft-lecture.pdf
Il \emph{Prime Factor Algorithm (PFA)}, anche chiamato \emph{Good-Thomas algorithm}, permettere di ridefinire una FFT con $N=N_1\times N_2$ come \emph{DFT bidimensionali} $N_1\times N_2$, ma solo nel caso che $N_1$ e $N_2$ siano \emph{coprimi}. La valutazione di queste DFT di taglia $N_1$ o $N_2$ può essere effettuato applicando ricorsivamente PFA stesso, se possibile, o qualunque altro algoritmo FFT.
Avere $N_1$ e $N_2$ coprimi permette di individuare facilmente una funzione biettiva per ri-indicizzare l'input e l'output di \eqref{eq:def-dft}.
Ciò ci permette di scrivere
\begin{align}
n &=n_1 N_2 + n_2 N_1  \mod N,\\ \nonumber
k &= k_1 N_2^{-1} N_2 + k_2 N_1^{-1} N_1 \mod N,\\
X_{k_1 N_2^{-1} N_2 + k_2 N_1^{-1} N_1} &=\sum_{n_1=0}^{N_1-1} \left( \sum_{n_2=0}^{N_2-1} x_{n_1 N_2 + n_2 N_1}e^{-\frac{2\pi i}{N_2} n_2 k_2 } \right)e^{-\frac{2\pi i}{N_1} n_1 k_1 }.
\end{align}
dove $N_1^{-1}$ è l'inverso di $N_1$ in aritmetica modulo $N_2$ e analogamente per $N_2^{-1}$.
La complessità dopo la scomposizione è $N\cdot (N_1+N_2)$ e iterando $O(N\log(N))$. Il numero di operazioni complessive è confrontabile con quello dello split-radix ma il numero di moltiplicazioni globale è inferiore.

\chapter{Stabilità Numerica}
Fin'ora abbiamo trattato la \emph{discrete Fourier transform} e la \emph{fast Fourier transform} pensando che potessero idealmente essere calcolate con assoluta precisione.
Tuttavia i calcolatori reali utilizzano parole di lunghezza finita e quindi anche i numeri e le operazioni aritmetiche sono soggetti ai limiti della 	\emph{rappresentazione in virgola mobile}.\\
E' fondamentale infatti che un algoritmo, oltre ad essere veloce, sia anche stabile quando opera in un contesto in virgola mobile con errore di arrotondamento $u$.\\
Mostreremo quindi come DFT e FFT siano estremamente sensibili rispetto alla precisione con cui vengono precalcolati i \emph{twiddle factors}, quale rapporto intercorre tra l'errore con DFT e FFT e come, sotto opportune ipotesi, gli algoritmi FFT possano essere considerati stabili.

Utilizando un modello standard di aritmetica binaria reale a precisione finita \cite{higham} se $x$ e $y$ sono numeri complessi esattamente rappresentabili si assume che

%ROUNDOFF ERROR pg 565
\newtheorem{Lemma}{Lemma}
\begin{Lemma}
Siano $x,y \in \mathbb{C}$, allora
\begin{alignat}{3}
fl(x\pm y) = (x\pm y) (1+\delta) 	\qquad \qquad && |\delta| &\leq u\\
fl(x\ast y) = (x\ast y) (1+\delta) 	\qquad \qquad&& |\delta| &\leq \sqrt{2}\frac{2u}{1-2nu}\\
fl(x\div y) = (x\div y) (1+\delta) 	\qquad \qquad && |\delta| &\leq \sqrt{2}\frac{4u}{1-4nu}
\end{alignat}
\end{Lemma}

Indichiamo con $\mathbf{\hat{z}}$ il risultato ottenuto da $fl(x \circ y)$ mentre con $\mathbf {z}$ il risultato esatto di $(x \circ y).$\\
\noindent Si suppone inoltre che gli esponenziali complessi $\omega_k$ siano pre-calcolati e su di essi sia stato commesso un errore $|\epsilon_{ik}|$ tale che:

\begin{equation*}
\hat{\omega}_j^k= fl(\omega_j^k)=\omega_j^k+\epsilon_{jk} \qquad |\epsilon_{jk}|\leq u
\end{equation*}

\section{Worst Case Error DFT}

\newtheorem{lemma2}{Lemma}
\begin{lemma2}\label{wilkinson}
\emph{(di Wilkinson)}
Se $\mathbf{A}$ è una matrice reale $p \times q$ e  $\mathbf{B}$ è una matrice reale $q \times r$, Allora
\begin{equation}
\frac{\left\|{fl(\mathbf{AB})-\mathbf{AB}}\right\|_2}{\left\|\mathbf{A}\right\|_2 \left\|\mathbf{B}\right\|_2}\leq 1.06 q 2^{-b} 	
\end{equation}
\end{lemma2}
\vskip 15pt
\newtheorem{Teorema}{Teorema}
\begin{Teorema} \label{Teorema:bound-dft}
Se si utilizza la definizione di DFT per calcolare la trasformata di Fourier discreta di una sequenza $\mathbf{x}$ di lunghezza $N$ in aritmetica a virgola mobile a lunghezza di parola costante con mantissa di $b$ bit, Allora
\begin{equation}
	\frac{\left\|\mathbf{\hat{x}-x}\right\|_2}{\left\|\mathbf{x}\right\|_2}\leq 1.06 \sqrt{N} {(2N)}^{3/2} 2^{-b}
\end{equation}
\end{Teorema}
\begin{proof}
Il calcolo per definizione della DFT è esprimibile attraverso una matrice $\mathbf{F} \in \mathbb{C}^{N \times N}$ dove $$\mathbf{F}_{i,j} =(\omega_N^{ij})_{i,k=0}^{N-1}$$
\begin{equation}
	\mathbf{\hat{x}}=\mathbf{F}\mathbf{x}
\end{equation}
$\mathbf{x}$ può essere visto come $\mathbf{x}={\rm Re}(\mathbf{x})+i{\rm Im}(\mathbf{x}) \leftrightarrow [{\rm Re}(\mathbf{x}), {\rm Im}(\mathbf{x})]$, vettore di lunghezza $2N$
Per definizione
\begin{align}
\label{eq:def-dft}
X_k&=\sum_{n=0}^{N-1}x_ne^{-\jmath\frac{2\pi}{N}kn} \quad k=0,...,N-1\\
&= \sum_{n=0}^{N-1}({\rm Re}(x)+\jmath{\rm Im}(x)) \left[ \cos\left( \frac{2\pi}{N}kn\right) - \jmath \sin \left(\frac{2\pi}{N}kn\right)\right]
\end{align}
Le operazioni complesse possono quindi essere espresse come operazioni reali attraverso una matrice $2N \times 2N$:
\[ \begin{bmatrix}
  {\rm Re}(\mathbf{\hat{x}}) \\
	{\rm Im}(\mathbf{\hat{x}})
 \end{bmatrix}= 
 \begin{bmatrix}
  \mathbf{C} & -\mathbf{S} \\
  \mathbf{S} & \mathbf{C}
 \end{bmatrix}
  \begin{bmatrix}
  {\rm Re}(\mathbf{x}) \\
	{\rm Im}(\mathbf{x}) \end{bmatrix} = \mathbf{M}
  \begin{bmatrix}
  {\rm Re}(\mathbf{x}) \\
	{\rm Im}(\mathbf{x}) \end{bmatrix}
\]
dove $\mathbf{C}_{i,j}=\cos\left(\frac{2\pi i j}{N}\right)$ e $\mathbf{S}_{i,j}=\sin\left(\frac{2\pi i j}{N}\right)$. Inoltre la norma 2 della matrice è

\begin{align*}
 \left\|\mathbf{M}\right\|_2&=\sqrt{\sum_{i=0}^{N-1}\sum_{j=0}^{N-1}\left\{ \cos^2\left(\frac{2\pi ij}{N}\right) +\sin^2\left(\frac{2\pi ij}{N}\right)+\cos^2\left(\frac{2\pi ij}{N}\right)+\sin^2\left(\frac{2\pi ij}{N}\right) \right\}}\\
 &=\sqrt{2N^2}
\end{align*}
Applicando il \emph{Lemma di Wilkinson} con, nel nostro caso $q=2N$, $\left\|\mathbf{M}\right\|_2=\sqrt{2} N$, ricordando che $\left\|\hat{\mathbf{x}}\right\|_2=\sqrt 2 \left \| \mathbf{x} \right \|_2$
\begin{equation}
\frac{\left\|{fl(\mathbf{Mx})-\mathbf{Mx}}\right\|_2}{\left\|\mathbf{M}\right\|_2 \left\|\mathbf{x}\right\|_2}\leq 1.06 q 2^{-b} = \frac{\left\|{fl(\mathbf{Mx})-\mathbf{\hat{{x}}}}\right\|_2}{\sqrt{2}N \left\|\mathbf{x}\right\|_2}\leq 1.06 2N 2^{-b} 
\end{equation}
\begin{equation}
	\frac{\left\|\mathbf{\hat{x}-x}\right\|_2}{\left\|\mathbf{x}\right\|_2}\leq 1.06 \sqrt{N} {(2N)}^{3/2} 2^{-b}
\end{equation}
\end{proof}


\section{Confronto DFT FFT}
\begin{figure}[h!]
  \centering
      \includegraphics[width=\textwidth]{immagini/errore-DFT-FFT}
  \caption{Norma 2 dell'errore tra $x_N$ e $\mathcal{F}^{-1}(\mathcal{F}(x_N))$}
\end{figure}

\chapter{Applicazioni}
%
% MURLI
%
%
\section{FFT of two Real Functions Simultaneosly}

%
% anche dal mitra oppure Brigham cap 1p pg 166
%
%

Nell'applicazione della FFT spesso consideriamo solo funzioni reali del tempo mentre le funzioni in frequenza utilizzate nei calcoli sono, in generale, funzioni complesse. Pertanto, un comune programma in grado determinare la DFT e la sua inversa è scritto in modo da ricevere in input una forma d'onda complessa
\begin{equation}
	H(n)=\sum_{k=0}^{N-1}\left[ h_r(k)+ jh_i(k)\right] e^{-j\frac{2\pi}{N}nk}
\end{equation}
Sfruttando la proprietà \eqref{eq:inverse_computing_rule} per il calcolo dell'inversa è possibile riscrivere
\begin{equation}
	h(k)=\frac{1}{N}{\left[\sum_{n=0}^{N-1}{\left[ H_r(n)+ jH_i(n)\right]}^* e^{-j\frac{2\pi}{N}nk}\right]}^*
\end{equation}
e poichè entrambe contengono $e^{-j\frac{2\pi}{N}nk}$ lo stesso programma può essere usato per calcolare sia la trasformata diretta che la sua inversa.

Se i dati in ingresso sono reali allora la loro parte immaginaria risulterà essere nulla. Tuttavia poichè i programmi effettuano comunque le operazioni anche per i coefficienti posti a zero, otteniamo uno spreco di capacità di calcolo. Varie tecniche possono essere adottate per aumentare l'efficienza di calcolo di sequenze rali.
Volendo infatti calcolare le trasformate di $h(k)$ e $g(k)$ è possibile considerare l'ingresso fittizio $y(k)=h(k)+jg(k)$\\
Per la linearità della DFT
\begin{align*}
Y(n)&= H(n)+jG(n)\\
&=[H_r(n)+jH_i(n)] + j[G_r(n)+jG_i(n)]\\
&=[H_r(n)-G_i(n)] + j [H_i(n)+G_r(n)]\\
&={\rm Re}(n)+j{\rm Imm}(n)
\end{align*}
\include{bibliografia}
\end{document}